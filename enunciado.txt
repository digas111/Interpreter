Trabalho 1:

Pretende-se escrever um interpretador para uma linguagem de programação definida por um conjunto de instruções
relativamente pequeno.

- Expressões: expressões aritméticas com um único operador. (exemplos: 2 + 3 , 4*x , y/z ).

- Inserção dum valor para uma variável: para que o utilizador possa indicar um valor para a variável identificada pela
 string referida na instrução. Caso a variável já tenha valor, esse valor será substituído pelo novo.
ler(<variável>);

- Escrever o valor de uma variável:
escrever(<variável>);

- Atribuir o valor duma expressão a uma variável: todas as variáveis que ocorram na expressão deverão ter já um valor
 definido; o valor da expressão será atribuído à variável que se encontra do lado esquerdo.
<variável> = <expressão>;

- labels: label <string>

- instruções goto: goto label

- comandos condicionais da forma: if <variável> goto <label>

- Terminar a execução do programa:
quit;

Um exemplo de uso desta linguagem:

ler(k);

p= 6 + k;

if p goto L1;

p = p/2;

escrever(p);

goto L2;

label L1;

p = 2*p;

escrever(p);

label L2;

quit;

/////////////
/////////////
output atual:

-ler(k)
-p=6+k
-if p goto L1
-p=p/2
-escrever(p)
-goto L2
-label L1
-p=2*p
-escrever(p)
-label L2
-quit


Sugestões:
1) use uma lista de instruções como input do interpretador, para lidar com os ciclos.
2) Mantenha os valores das variáveis numa tabela de hash.
3) Uma sugestão possível para representar instruções são quádruplos (por exemplo p = 2*p seria representado por (MUL, p, 2, p) e label L1 por (LABEL, L1, EMPTY, EMPTY).).
4) Esta estrutura pode ser representada em C da forma seguinte:

typedef enum {ATRIB, ADD, SUB, MUL, IF_I, PRINT, READ, GOTO_I, LABEL,...} OpKind;

typedef enum {EMPTY, INT_CONST, STRING} ElemKind;

typedef struct
                {
                   ElemKind kind;
                   union
                    {
                      int val;
                      char *name;
                     } contents;
                  } Elem;

typedef struct
                 {
                    OpKind op;
                    Elem first, second, third;
                  } Instr;

// Prazo para Entrega: 8 de Abril
//
// Os trabalhos deverão ser feitos em grupos de dois alunos. Deverão ser enviados por email para o respectivo docente
// das práticas e apresentados (numa apresentação breve) ao docente durante as aulas práticas da semana de 8 a 12 de
// Abril.


char *keywords[] = {"-ler(", "-if", "-escrever(", "-goto", "-label",
"-quit", "+", "-", "*", "/"};

_________________________________________________________________

Nossa interpretação

Comandos:
      ler(k) -> (READ, k, EMPTY,EMPTY);
      escrever(k) -> (PRINT, k, EMPTY,EMPTY);
      if k goto L2 -> (IF, k, L2, EMPTY);
      goto L1 -> (GOTO,L1,EMPTY,EMPTY);
      label L1 -> (LABEL,L1,EMPTY,EMPTY);
      quit -> (QUIT,EMPTY,EMPTY,EMPTY);
      p=3+6 -> (ADD,p,3,6);
      p=3-6 -> (SUB,p,3,6);
      p=3/6 -> (DIV,p,3,6);
      p=3*6 -> (MUL,p,3,6);
      p=6 -> (ATRIB,p,6,EMPTY);

main-
hash -
  HASHNODE *new_hashnode(char *name, int value, HASHNODE *next);
  unsigned int hash (char *str);
  int get_value(HASHNODE *in_hash[], char *name);
  HASHNODE *save(HASHNODE *in_hash[], char *name);

linkedlist -
  void print_llist(NODE *list);
  int length(NODE *list);
  NODE *new_node(Instr *instr);
  NODE *add_last(Instr *instr, NODE *list);

instr -
  Instr *new_instr(OpKind k,char *elem1, char *elem2, char *elem3);
  Instr *instrfy(char *line);

exec-
  void exec(NODE *program);
  void exec_instr(Instr* command);

read-
  NODE *file_to_llist(char file_name[]);
  char *dell_spaces(char *input);
  char* string_add_last(char string[], int *size, char c);
